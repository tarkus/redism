// Generated by CoffeeScript 1.7.1
var Multi, Redison, SHARDABLE, UNSHARDABLE, assert, hasher, redis, step,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

assert = require('assert');

redis = require('redis');

step = require('step');

hasher = require('./hasher');

SHARDABLE = ["append", "bitcount", "blpop", "brpop", "debug object", "decr", "decrby", "del", "dump", "exists", "expire", "expireat", "get", "getbit", "getrange", "getset", "hdel", "hexists", "hget", "hgetall", "hincrby", "hincrbyfloat", "hkeys", "hlen", "hmget", "hmset", "hset", "hsetnx", "hvals", "incr", "incrby", "incrbyfloat", "lindex", "linsert", "llen", "lpop", "lpush", "lpushx", "lrange", "lrem", "lset", "ltrim", "mget", "move", "persist", "pexpire", "pexpireat", "psetex", "pttl", "rename", "renamenx", "restore", "rpop", "rpush", "rpushx", "sadd", "scard", "sdiff", "set", "setbit", "setex", "setnx", "setrange", "sinter", "sismember", "smembers", "sort", "spop", "srandmember", "srem", "strlen", "sunion", "ttl", "type", "watch", "zadd", "zcard", "zcount", "zincrby", "zrange", "zrangebyscore", "zrank", "zrem", "zremrangebyrank", "zremrangebyscore", "zrevrange", "zrevrangebyscore", "zrevrank", "zscore"];

UNSHARDABLE = ["auth", "bgrewriteaof", "bgsave", "bitop", "brpoplpush", "client kill", "client list", "client getname", "client setname", "config get", "config set", "config resetstat", "dbsize", "debug segfault", "discard", "echo", "eval", "evalsha", "exec", "flushall", "flushdb", "info", "keys", "lastsave", "migrate", "monitor", "mset", "msetnx", "multi", "object", "ping", "psubscribe", "publish", "punsubscribe", "quit", "randomkey", "rpoplpush", "save", "script exists", "script flush", "script kill", "script load", "sdiffstore", "select", "shutdown", "sinterstore", "slaveof", "slowlog", "smove", "subscribe", "sunionstore", "sync", "time", "unsubscribe", "unwatch", "zinterstore", "zunionstore"];

Redison = (function() {
  Redison.prototype.clients = {};

  function Redison(options) {
    this.options = options;
    this.multi = __bind(this.multi, this);
    assert(!!this.options, "options must be an object");
    assert(Array.isArray(this.options.servers), "servers must be an array");
    this.options.servers.forEach((function(_this) {
      return function(server) {
        var client, fields;
        fields = server.split(/:/);
        client = redis.createClient(parseInt(fields[1], 10), fields[0]);
        if (_this.options.database) {
          client.select(_this.options.database);
        }
        if (_this.options.password) {
          client.auth(_this.options.password);
        }
        return _this.clients[server] = client;
      };
    })(this));
    this.servers = Object.keys(this.clients);
    SHARDABLE.forEach((function(_this) {
      return function(command) {
        return _this[command] = function() {
          var client, node;
          node = _this.nodeFor(arguments[0]);
          client = _this.clients[node];
          return client[command].apply(client, arguments);
        };
      };
    })(this));
    UNSHARDABLE.forEach((function(_this) {
      return function(command) {
        if (command === 'multi') {
          return;
        }
        return _this[command] = function() {
          throw new Error("" + command + " is not shardable");
        };
      };
    })(this));
  }

  Redison.prototype.multi = function() {
    return new Multi(this);
  };

  Redison.prototype.nodeFor = function(key) {
    var mod;
    mod = parseInt(hasher.crc32(key), 16) % this.servers.length;
    return this.servers[mod];
  };

  return Redison;

})();

Multi = (function() {
  Multi.prototype.multis = {};

  Multi.prototype.interlachen = [];

  Multi.prototype.counter = {};

  function Multi(redison) {
    this.redison = redison;
    this.exec = __bind(this.exec, this);
    SHARDABLE.forEach((function(_this) {
      return function(command) {
        return _this[command] = function() {
          var multi, node;
          node = _this.redison.nodeFor(arguments[0]);
          multi = _this.multis[node];
          if (!multi) {
            multi = _this.multis[node] = _this.redison.clients[node].multi();
          }
          _this.interlachen.push(node);
          if (_this.counter[node] == null) {
            _this.counter[node] = 0;
          }
          _this.counter[node] += 1;
          multi[command].apply(multi, arguments);
          return _this;
        };
      };
    })(this));
    UNSHARDABLE.forEach((function(_this) {
      return function(command) {
        if (command === 'exec') {
          return;
        }
        return _this[command] = function() {
          throw new Error("" + command + " is not supported");
        };
      };
    })(this));
  }

  Multi.prototype.exec = function(callback) {
    var nodes, self;
    nodes = Object.keys(this.multis);
    self = this;
    return step(function() {
      var group;
      group = this.group();
      return nodes.forEach(function(node) {
        return self.multis[node].exec(group());
      });
    }, function(error, groups) {
      var results;
      if (error) {
        return callback(error);
      }
      assert(nodes.length === groups.length, "wrong number of response");
      results = [];
      groups.forEach(function(results, index) {
        var node;
        node = nodes[index];
        return assert(results.length === self.counter[node], "" + node + " is missing results");
      });
      self.interlachen.forEach(function(node) {
        var index;
        index = nodes.indexOf(node);
        return results.push(groups[index].shift());
      });
      return callback(null, results);
    });
  };

  return Multi;

})();

module.exports = Redison;
