// Generated by CoffeeScript 1.7.1
var Multi, Redison, SHARDABLE, UNSHARDABLE, assert, hasher, redis, step, _,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

_ = require('underscore');

assert = require('assert');

redis = require('redis');

step = require('step');

hasher = require('./hasher');

SHARDABLE = ["append", "bitcount", "blpop", "brpop", "debug object", "decr", "decrby", "del", "dump", "exists", "expire", "expireat", "get", "getbit", "getrange", "getset", "hdel", "hexists", "hget", "hgetall", "hincrby", "hincrbyfloat", "hkeys", "hlen", "hmget", "hmset", "hset", "hsetnx", "hvals", "incr", "incrby", "incrbyfloat", "lindex", "linsert", "llen", "lpop", "lpush", "lpushx", "lrange", "lrem", "lset", "ltrim", "mget", "move", "persist", "pexpire", "pexpireat", "psetex", "pttl", "rename", "renamenx", "restore", "rpop", "rpush", "rpushx", "sadd", "scard", "sdiff", "set", "setbit", "setex", "setnx", "setrange", "sinter", "sismember", "smembers", "sort", "spop", "srandmember", "srem", "strlen", "sunion", "ttl", "type", "watch", "zadd", "zcard", "zcount", "zincrby", "zrange", "zrangebyscore", "zrank", "zrem", "zremrangebyrank", "zremrangebyscore", "zrevrange", "zrevrangebyscore", "zrevrank", "zscore"];

UNSHARDABLE = ["auth", "bgrewriteaof", "bgsave", "bitop", "brpoplpush", "client kill", "client list", "client getname", "client setname", "config get", "config set", "config resetstat", "dbsize", "debug segfault", "discard", "echo", "eval", "evalsha", "exec", "flushall", "flushdb", "info", "keys", "lastsave", "migrate", "monitor", "mset", "msetnx", "multi", "object", "ping", "psubscribe", "publish", "punsubscribe", "quit", "randomkey", "rpoplpush", "save", "script exists", "script flush", "script kill", "script load", "sdiffstore", "select", "shutdown", "sinterstore", "slaveof", "slowlog", "smove", "subscribe", "sunionstore", "sync", "time", "unsubscribe", "unwatch", "zinterstore", "zunionstore"];


/*
 * Simple options
 * {
 *   servers: [ 'localhost:6379', 'localhost:6479' ]
 *   password: 'SxZRihb3A5LB6XtrmIU7XOgBAndBbhW47pxx'
 *   database: 3
 * }
 * 
 * Options with scopes
 *
 * {
 *   servers: [
 *     [ ':hash:', [ 'localhost:6579', 'localhost:6679' ] ]
 *     [ 'localhost:6379', 'localhost:6479' ],
 *   ]
 *   password: 'SxZRihb3A5LB6XtrmIU7XOgBAndBbhW47pxx'
 *   database: 3
 * }
 *
 */

Redison = (function() {
  function Redison(options) {
    var scoped, _i, _len, _ref, _servers;
    this.options = options;
    this.multi = __bind(this.multi, this);
    assert(!!this.options, "options must be an object");
    if (!this.options.servers) {
      this.options.servers = ['localhost:6379'];
    }
    this.clients = {};
    this.servers = {
      "default": null,
      scopes: {}
    };
    _servers = [];
    if (typeof this.options.servers[0] !== 'string') {
      _ref = this.options.servers;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        scoped = _ref[_i];
        if (Array.isArray(scoped[1])) {
          this.servers.scopes[scoped[0]] = scoped[1];
          _servers = _.union(_servers, scoped[1]);
        } else {
          this.servers["default"] = scoped;
          _servers = _.union(_servers, scoped);
        }
      }
    } else {
      this.servers["default"] = this.options.servers;
      _servers = this.options.servers;
    }
    assert(Array.isArray(this.servers["default"]), "default servers must be set");
    _servers.forEach((function(_this) {
      return function(server) {
        var client, fields;
        fields = server.split(/:/);
        client = redis.createClient(parseInt(fields[1], 10), fields[0]);
        if (_this.options.database) {
          client.select(_this.options.database);
        }
        if (_this.options.password) {
          client.auth(_this.options.password);
        }
        return _this.clients[server] = client;
      };
    })(this));
    SHARDABLE.forEach((function(_this) {
      return function(command) {
        return _this[command] = function() {
          var client, node;
          node = _this.nodeFor(arguments[0]);
          client = _this.clients[node];
          return client[command].apply(client, arguments);
        };
      };
    })(this));
    UNSHARDABLE.forEach((function(_this) {
      return function(command) {
        if (command === 'multi') {
          return;
        }
        return _this[command] = function() {
          throw new Error("" + command + " is not shardable");
        };
      };
    })(this));
  }

  Redison.prototype.multi = function() {
    return new Multi(this);
  };

  Redison.prototype.nodeFor = function(key) {
    var mod, scope, servers, _ref;
    if (this.servers.scopes) {
      _ref = this.servers.scopes;
      for (scope in _ref) {
        servers = _ref[scope];
        if (!key.match(scope)) {
          continue;
        }
        mod = parseInt(hasher.crc32(key), 16) % servers.length;
        return servers[mod];
      }
    }
    mod = parseInt(hasher.crc32(key), 16) % this.servers["default"].length;
    return this.servers["default"][mod];
  };

  return Redison;

})();

Multi = (function() {
  Multi.prototype.multis = {};

  Multi.prototype.interlachen = [];

  Multi.prototype.counter = {};

  function Multi(redison) {
    this.redison = redison;
    this.exec = __bind(this.exec, this);
    SHARDABLE.forEach((function(_this) {
      return function(command) {
        return _this[command] = function() {
          var multi, node;
          node = _this.redison.nodeFor(arguments[0]);
          multi = _this.multis[node];
          if (!multi) {
            multi = _this.multis[node] = _this.redison.clients[node].multi();
          }
          _this.interlachen.push(node);
          if (_this.counter[node] == null) {
            _this.counter[node] = 0;
          }
          _this.counter[node] += 1;
          multi[command].apply(multi, arguments);
          return _this;
        };
      };
    })(this));
    UNSHARDABLE.forEach((function(_this) {
      return function(command) {
        if (command === 'exec') {
          return;
        }
        return _this[command] = function() {
          throw new Error("" + command + " is not supported");
        };
      };
    })(this));
  }

  Multi.prototype.exec = function(callback) {
    var nodes, self;
    nodes = Object.keys(this.multis);
    self = this;
    return step(function() {
      var group;
      group = this.group();
      return nodes.forEach(function(node) {
        return self.multis[node].exec(group());
      });
    }, function(error, groups) {
      var results;
      if (error) {
        return callback(error);
      }
      assert(nodes.length === groups.length, "wrong number of response");
      results = [];
      groups.forEach(function(results, index) {
        var node;
        node = nodes[index];
        return assert(results.length === self.counter[node], "" + node + " is missing results");
      });
      self.interlachen.forEach(function(node) {
        var index;
        index = nodes.indexOf(node);
        return results.push(groups[index].shift());
      });
      return typeof callback === "function" ? callback(null, results) : void 0;
    });
  };

  return Multi;

})();

module.exports = Redison;
