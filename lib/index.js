// Generated by CoffeeScript 1.7.1
var Multi, Redison, SHARDABLE, UNSHARDABLE, assert, hasher, redis, step, _,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

_ = require('underscore');

assert = require('assert');

redis = require('redis');

step = require('step');

hasher = require('./hasher');

SHARDABLE = ["append", "bitcount", "blpop", "brpop", "debug object", "decr", "decrby", "del", "dump", "exists", "expire", "expireat", "get", "getbit", "getrange", "getset", "hdel", "hexists", "hget", "hgetall", "hincrby", "hincrbyfloat", "hkeys", "hlen", "hmget", "hmset", "hset", "hsetnx", "hvals", "incr", "incrby", "incrbyfloat", "lindex", "linsert", "llen", "lpop", "lpush", "lpushx", "lrange", "lrem", "lset", "ltrim", "mget", "move", "persist", "pexpire", "pexpireat", "psetex", "pttl", "rename", "renamenx", "restore", "rpop", "rpush", "rpushx", "sadd", "scard", "sdiff", "set", "setbit", "setex", "setnx", "setrange", "sinter", "sismember", "smembers", "sort", "spop", "srandmember", "srem", "strlen", "sunion", "ttl", "type", "watch", "zadd", "zcard", "zcount", "zincrby", "zrange", "zrangebyscore", "zrank", "zrem", "zremrangebyrank", "zremrangebyscore", "zrevrange", "zrevrangebyscore", "zrevrank", "zscore"];

UNSHARDABLE = ["auth", "bgrewriteaof", "bgsave", "bitop", "brpoplpush", "client kill", "client list", "client getname", "client setname", "config get", "config set", "config resetstat", "dbsize", "debug segfault", "discard", "echo", "eval", "evalsha", "exec", "flushall", "flushdb", "info", "keys", "lastsave", "migrate", "monitor", "mset", "msetnx", "multi", "object", "ping", "psubscribe", "publish", "punsubscribe", "quit", "randomkey", "rpoplpush", "save", "script exists", "script flush", "script kill", "script load", "sdiffstore", "select", "shutdown", "sinterstore", "slaveof", "slowlog", "smove", "subscribe", "sunionstore", "sync", "time", "unsubscribe", "unwatch", "zinterstore", "zunionstore"];


/*
 * Simple options
 * {
 *   servers: [ 'localhost:6379', 'localhost:6479' ]
 *   password: 'SxZRihb3A5LB6XtrmIU7XOgBAndBbhW47pxx'
 *   database: 3
 * }
 * 
 * Options with scopes
 *
 * {
 *   servers: [
 *     [ ':hash:', [ 'localhost:6579', 'localhost:6679' ] ]
 *     [ 'localhost:6379', 'localhost:6479' ],
 *   ]
 *   password: 'SxZRihb3A5LB6XtrmIU7XOgBAndBbhW47pxx'
 *   database: 3
 * }
 *
 */

Redison = (function() {
  function Redison(options) {
    var client, scoped, _i, _len, _ref, _servers;
    this.options = options;
    this.multi = __bind(this.multi, this);
    this.zinterstore = __bind(this.zinterstore, this);
    this.sinterstore = __bind(this.sinterstore, this);
    this.mset = __bind(this.mset, this);
    assert(!!this.options, "options must be an object");
    if (!this.options.servers) {
      this.options.servers = ['localhost:6379'];
    }
    this.clients = {};
    this.servers = {
      "default": null,
      scopes: {}
    };
    _servers = [];
    if (typeof this.options.servers[0] !== 'string') {
      _ref = this.options.servers;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        scoped = _ref[_i];
        if (Array.isArray(scoped[1])) {
          this.servers.scopes[scoped[0]] = scoped[1];
          _servers = _.union(_servers, scoped[1]);
        } else {
          this.servers["default"] = scoped;
          _servers = _.union(_servers, scoped);
        }
      }
    } else {
      this.servers["default"] = this.options.servers;
      _servers = this.options.servers;
    }
    assert(Array.isArray(this.servers["default"]), "default servers must be set");
    client = _servers.forEach((function(_this) {
      return function(server) {
        var fields;
        fields = server.split(/:/);
        client = redis.createClient(parseInt(fields[1], 10), fields[0]);
        if (_this.options.database) {
          client.select(_this.options.database);
        }
        if (_this.options.password) {
          client.auth(_this.options.password);
        }
        _this.clients[server] = client;
        return client;
      };
    })(this));
    this.connected = true;
    SHARDABLE.forEach((function(_this) {
      return function(command) {
        return _this[command] = function() {
          var node;
          node = _this.nodeFor(arguments[0]);
          client = _this.clients[node];
          return client[command].apply(client, arguments);
        };
      };
    })(this));
    UNSHARDABLE.forEach((function(_this) {
      return function(command) {
        if (command === 'multi' || command === 'mset' || command === 'sinterstore' || command === 'zinterstore') {
          return;
        }
        return _this[command] = function() {
          throw new Error("" + command + " is not shardable");
        };
      };
    })(this));
  }

  Redison.prototype.mset = function() {
    var arg, args, callback, idx, length, _i, _len;
    args = Array.prototype.slice.call(arguments);
    length = args.length;
    callback = null;
    if (typeof args[length - 1] === 'function') {
      callback = args.pop();
    }
    if (Array.isArray(args[0])) {
      args = args[0];
    }
    if (args.length % 2 !== 0) {
      throw new Error("wrong arguments given");
    }
    for (idx = _i = 0, _len = args.length; _i < _len; idx = _i += 2) {
      arg = args[idx];
      if (idx + 1 === args.length - 1) {
        this.set(arg, arguments[idx + 1], callback);
      } else {
        this.set(arg, arguments[idx + 1]);
      }
    }
    return this;
  };

  Redison.prototype.sinterstore = function() {
    var client, key, node;
    if (Array.isArray(arguments[0])) {
      key = arguments[0][0];
    } else {
      key = arguments[0];
    }
    node = this.nodeFor(key);
    client = this.clients[node];
    return client.sinterstore.call(client, arguments);
  };

  Redison.prototype.zinterstore = function() {
    var client, key, node;
    if (Array.isArray(arguments[0])) {
      key = arguments[0][0];
    } else {
      key = arguments[0];
    }
    node = this.nodeFor(key);
    client = this.clients[node];
    return client.zinterstore.call(client, arguments);
  };

  Redison.prototype.multi = function() {
    return new Multi(this);
  };

  Redison.prototype.nodeFor = function(key) {
    var mod, scope, servers, _ref;
    if (this.servers.scopes) {
      _ref = this.servers.scopes;
      for (scope in _ref) {
        servers = _ref[scope];
        if (!key.match(scope)) {
          continue;
        }
        mod = parseInt(hasher.crc32(key), 16) % servers.length;
        return servers[mod];
      }
    }
    mod = parseInt(hasher.crc32(key), 16) % this.servers["default"].length;
    return this.servers["default"][mod];
  };

  Redison.prototype.on = function(event, callback) {
    var first;
    first = this.servers["default"][0];
    return this.clients[first].on(event, callback);
  };

  return Redison;

})();

Multi = (function() {
  Multi.prototype.multis = {};

  Multi.prototype.interlachen = [];

  Multi.prototype.counter = {};

  function Multi(redison) {
    this.redison = redison;
    this.exec = __bind(this.exec, this);
    this.zinterstore = __bind(this.zinterstore, this);
    this.sinterstore = __bind(this.sinterstore, this);
    this.mset = __bind(this.mset, this);
    SHARDABLE.forEach((function(_this) {
      return function(command) {
        return _this[command] = function() {
          var multi, node;
          node = _this.redison.nodeFor(arguments[0]);
          multi = _this.multis[node];
          if (!multi) {
            multi = _this.multis[node] = _this.redison.clients[node].multi();
          }
          _this.interlachen.push(node);
          if (_this.counter[node] == null) {
            _this.counter[node] = 0;
          }
          _this.counter[node] += 1;
          multi[command].apply(multi, arguments);
          return _this;
        };
      };
    })(this));
    UNSHARDABLE.forEach((function(_this) {
      return function(command) {
        if (command === 'exec' || command === 'mset' || command === 'sinterstore' || command === 'zinterstore') {
          return;
        }
        return _this[command] = function() {
          throw new Error("" + command + " is not supported");
        };
      };
    })(this));
  }

  Multi.prototype.mset = function() {
    var arg, args, callback, idx, length, _i, _len;
    args = Array.prototype.slice.call(arguments);
    length = args.length;
    callback = null;
    if (typeof args[length - 1] === 'function') {
      callback = args.pop();
    }
    if (Array.isArray(args[0])) {
      args = args[0];
    }
    if (args.length % 2 !== 0) {
      throw new Error("wrong arguments given");
    }
    for (idx = _i = 0, _len = args.length; _i < _len; idx = _i += 2) {
      arg = args[idx];
      if (idx + 1 === args.length - 1) {
        this.set(arg, arguments[idx + 1], callback);
      } else {
        this.set(arg, arguments[idx + 1]);
      }
    }
    return this;
  };

  Multi.prototype.sinterstore = function() {
    var key, multi, node;
    if (Array.isArray(arguments[0])) {
      key = arguments[0][0];
    } else {
      key = arguments[0];
    }
    node = this.nodeFor(key);
    multi = this.multis[node];
    if (!multi) {
      multi = this.multis[node] = this.redison.clients[node].multi();
    }
    this.interlachen.push(node);
    if (this.counter[node] == null) {
      this.counter[node] = 0;
    }
    this.counter[node] += 1;
    return multi.sinterstore.call(multi, arguments);
  };

  Multi.prototype.zinterstore = function() {
    var key, multi, node;
    if (Array.isArray(arguments[0])) {
      key = arguments[0][0];
    } else {
      key = arguments[0];
    }
    node = this.nodeFor(key);
    multi = this.multis[node];
    if (!multi) {
      multi = this.multis[node] = this.redison.clients[node].multi();
    }
    this.interlachen.push(node);
    if (this.counter[node] == null) {
      this.counter[node] = 0;
    }
    this.counter[node] += 1;
    return multi.zinterstore.call(multi, arguments);
  };

  Multi.prototype.exec = function(callback) {
    var nodes, self;
    nodes = Object.keys(this.multis);
    self = this;
    return step(function() {
      var group;
      group = this.group();
      return nodes.forEach(function(node) {
        return self.multis[node].exec(group());
      });
    }, function(error, groups) {
      var results;
      if (error) {
        return callback(error);
      }
      assert(nodes.length === groups.length, "wrong number of response");
      results = [];
      groups.forEach(function(results, index) {
        var node;
        node = nodes[index];
        return assert(results.length === self.counter[node], "" + node + " is missing results");
      });
      self.interlachen.forEach(function(node) {
        var index;
        index = nodes.indexOf(node);
        return results.push(groups[index].shift());
      });
      return typeof callback === "function" ? callback(null, results) : void 0;
    });
  };

  return Multi;

})();

module.exports = Redison;
